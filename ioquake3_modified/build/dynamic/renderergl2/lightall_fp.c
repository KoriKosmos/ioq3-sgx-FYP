const char *fallbackShader_lightall_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP) || defined(USE_DELUXEMAP) || defined(USE_SPECULARMAP) || defined(USE_CUBEMAP)\n"
"// y = deluxe, w = cube\n"
"uniform vec4      u_EnableTextures; \n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec4      u_NormalScale;\n"
"uniform vec4      u_SpecularScale;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#if defined(USE_CUBEMAP)\n"
"uniform vec4      u_CubeMapInfo;\n"
"#endif\n"
"#endif\n"
"\n"
"uniform int       u_AlphaTest;\n"
"\n"
"varying vec4      var_TexCoords;\n"
"\n"
"varying vec4      var_Color;\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"varying vec4      var_ColorAmbient;\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"varying vec4   var_Normal;\n"
"varying vec4   var_Tangent;\n"
"varying vec4   var_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"varying vec4      var_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec4      var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"\treturn 1.0 - texture2D(normalMap, t).r;\n"
"  #else\n"
"\treturn 1.0 - texture2D(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"\tconst int linearSearchSteps = 16;\n"
"\tconst int binarySearchSteps = 6;\n"
"\n"
"\t// current size of search window\n"
"\tfloat size = 1.0 / float(linearSearchSteps);\n"
"\n"
"\t// adjust position if offset above surface\n"
"\tdp -= ds * r_parallaxMapOffset;\n"
"\n"
"\t// current depth position\n"
"\tfloat depth = 0.0;\n"
"\n"
"\t// best match found (starts with last position 1.0)\n"
"\tfloat bestDepth = 1.0;\n"
"\n"
"\t// texture depth at best depth\n"
"\tfloat texDepth = 0.0;\n"
"\n"
"\tfloat prevT = SampleDepth(normalMap, dp);\n"
"\tfloat prevTexDepth = prevT;\n"
"\n"
"\t// search front to back for first point inside object\n"
"\tfor(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"\t{\n"
"\t\tdepth += size;\n"
"\t\t\n"
"\t\tfloat t = SampleDepth(normalMap, dp + ds * depth);\n"
"\t\t\n"
"\t\tif(bestDepth > 0.996)\t\t// if no depth found yet\n"
"\t\t\tif(depth >= t)\n"
"\t\t\t{\n"
"\t\t\t\tbestDepth = depth;\t// store best depth\n"
"\t\t\t\ttexDepth = t;\n"
"\t\t\t\tprevTexDepth = prevT;\n"
"\t\t\t}\n"
"\t\tprevT = t;\n"
"\t}\n"
"\n"
"\tdepth = bestDepth;\n"
"\n"
"#if !defined (USE_RELIEFMAP)\n"
"\tfloat div = 1.0 / (1.0 + (prevTexDepth - texDepth) * float(linearSearchSteps));\n"
"\tbestDepth -= (depth - size - prevTexDepth) * div;\n"
"#else\n"
"\t// recurse around first point (depth) for closest match\n"
"\tfor(int i = 0; i < binarySearchSteps; ++i)\n"
"\t{\n"
"\t\tsize *= 0.5;\n"
"\n"
"\t\tfloat t = SampleDepth(normalMap, dp + ds * depth);\n"
"\t\t\n"
"\t\tif(depth >= t)\n"
"\t\t{\n"
"\t\t\tbestDepth = depth;\n"
"\t\t\tdepth -= 2.0 * size;\n"
"\t\t}\n"
"\n"
"\t\tdepth += size;\n"
"\t}\n"
"#endif\n"
"\n"
"\treturn bestDepth - r_parallaxMapOffset;\n"
"}\n"
"\n"
"float LightRay(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"\tconst int linearSearchSteps = 16;\n"
"\n"
"\t// current size of search window\n"
"\tfloat size = 1.0 / float(linearSearchSteps);\n"
"\n"
"\t// current height from initial texel depth\n"
"\tfloat height = 0.0;\n"
"\n"
"\tfloat startDepth = SampleDepth(normalMap, dp);\n"
"\n"
"\t// find a collision or escape\n"
"\tfor(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"\t{\n"
"\t\theight += size;\n"
"\n"
"\t\tif (startDepth < height)\n"
"\t\t\treturn 1.0;\n"
"\t\t\n"
"\t\tfloat t = SampleDepth(normalMap, dp + ds * height);\n"
"\n"
"\t\tif (startDepth > t + height)\n"
"\t\t\treturn 0.0;\n"
"\t}\n"
"\n"
"\treturn 1.0;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"\t// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"\tfloat fd90 = -0.5 + EH * EH * roughness;\n"
"\tfloat burley = 1.0 + fd90 * 0.04 / NH;\n"
"\tburley *= burley;\n"
"\treturn diffuseAlbedo * burley;\n"
"#else\n"
"\treturn diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"vec3 EnvironmentBRDF(float roughness, float NE, vec3 specular)\n"
"{\n"
"\t// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"\tfloat v = 1.0 - max(roughness, NE);\n"
"\tv *= v * v;\n"
"\treturn vec3(v) + specular;\n"
"}\n"
"\n"
"vec3 CalcSpecular(vec3 specular, float NH, float EH, float roughness)\n"
"{\n"
"\t// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"\tfloat rr = roughness*roughness;\n"
"\tfloat rrrr = rr*rr;\n"
"\tfloat d = (NH * NH) * (rrrr - 1.0) + 1.0;\n"
"\tfloat v = (EH * EH) * (roughness + 0.5) + EPSILON;\n"
"\treturn specular * (rrrr / (4.0 * d * d * v));\n"
"}\n"
"\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"\t// zero light at 1.0, approximating q3 style\n"
"\t// also don't attenuate directional light\n"
"\tfloat attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"\n"
"\t// clamp attenuation\n"
"\t#if defined(NO_LIGHT_CLAMP)\n"
"\tattenuation = max(attenuation, 0.0);\n"
"\t#else\n"
"\tattenuation = clamp(attenuation, 0.0, 1.0);\n"
"\t#endif\n"
"\n"
"\treturn attenuation;\n"
"}\n"
"\n"
"#if defined(USE_BOX_CUBEMAP_PARALLAX)\n"
"vec4 hitCube(vec3 ray, vec3 pos, vec3 invSize, float lod, samplerCube tex)\n"
"{\n"
"\t// find any hits on cubemap faces facing the camera\n"
"\tvec3 scale = (sign(ray) - pos) / ray;\n"
"\n"
"\t// find the nearest hit\n"
"\tfloat minScale = min(min(scale.x, scale.y), scale.z);\n"
"\n"
"\t// if the nearest hit is behind the camera, ignore\n"
"\t// should not be necessary as long as pos is inside the cube\n"
"\t//if (minScale < 0.0)\n"
"\t\t//return vec4(0.0);\n"
"\n"
"\t// calculate the hit position, that's our texture coordinates\n"
"\tvec3 tc = pos + ray * minScale;\n"
"\n"
"\t// if the texture coordinates are outside the cube, ignore\n"
"\t// necessary since we're not fading out outside the cube\n"
"\tif (any(greaterThan(abs(tc), vec3(1.00001))))\n"
"\t\treturn vec4(0.0);\n"
"\n"
"\t// fade out when approaching the cubemap edges\n"
"\t//vec3 fade3 = abs(pos);\n"
"\t//float fade = max(max(fade3.x, fade3.y), fade3.z);\n"
"\t//fade = clamp(1.0 - fade, 0.0, 1.0);\n"
"\t\t\t\n"
"\t//return vec4(textureCubeLod(tex, tc, lod).rgb * fade, fade);\n"
"\treturn vec4(textureCubeLod(tex, tc, lod).rgb, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"\tvec3 viewDir, lightColor, ambientColor, reflectance;\n"
"\tvec3 L, N, E, H;\n"
"\tfloat NL, NH, NE, EH, attenuation;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"\tvec3 surfNormal = (!gl_FrontFacing ? var_Normal : -var_Normal).xyz;\n"
"\tmat3 tangentToWorld = mat3(var_Tangent.xyz, var_Bitangent.xyz, surfNormal);\n"
"\tviewDir = vec3(var_Normal.w, var_Tangent.w, var_Bitangent.w);\n"
"\tE = normalize(viewDir);\n"
"#endif\n"
"\n"
"\tlightColor = var_Color.rgb;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvec4 lightmapColor = texture2D(u_LightMap, var_TexCoords.zw);\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"\tlightmapColor.rgb *= lightmapColor.a;\n"
"  #endif\n"
"  #if defined(USE_PBR) && !defined(USE_FAST_LIGHT)\n"
"\tlightmapColor.rgb *= lightmapColor.rgb;\n"
"  #endif\n"
"\tlightColor *= lightmapColor.rgb;\n"
"#endif\n"
"\n"
"\tvec2 texCoords = var_TexCoords.xy;\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"\tvec3 offsetDir = E * tangentToWorld;\n"
"\n"
"\toffsetDir.xy *= -u_NormalScale.a / offsetDir.z;\n"
"\n"
"\ttexCoords += offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"#endif\n"
"\n"
"\tvec4 diffuse = texture2D(u_DiffuseMap, texCoords);\n"
"\t\n"
"\tfloat alpha = diffuse.a * var_Color.a;\n"
"\tif (u_AlphaTest == 1)\n"
"\t{\n"
"\t\tif (alpha == 0.0)\n"
"\t\t\tdiscard;\n"
"\t}\n"
"\telse if (u_AlphaTest == 2)\n"
"\t{\n"
"\t\tif (alpha >= 0.5)\n"
"\t\t\tdiscard;\n"
"\t}\n"
"\telse if (u_AlphaTest == 3)\n"
"\t{\n"
"\t\tif (alpha < 0.5)\n"
"\t\t\tdiscard;\n"
"\t}\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"\tL = var_LightDir.xyz;\n"
"  #if defined(USE_DELUXEMAP)\n"
"\tL += (texture2D(u_DeluxeMap, var_TexCoords.zw).xyz - vec3(0.5)) * u_EnableTextures.y;\n"
"  #endif\n"
"\tfloat sqrLightDist = dot(L, L);\n"
"\tL /= sqrt(sqrLightDist);\n"
"\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"\tattenuation  = CalcLightAttenuation(float(var_LightDir.w > 0.0), var_LightDir.w / sqrLightDist);\n"
"  #else\n"
"\tattenuation  = 1.0;\n"
"  #endif\n"
"\n"
"  #if defined(USE_NORMALMAP)\n"
"    #if defined(SWIZZLE_NORMALMAP)\n"
"\tN.xy = texture2D(u_NormalMap, texCoords).ag - vec2(0.5);\n"
"    #else\n"
"\tN.xy = texture2D(u_NormalMap, texCoords).rg - vec2(0.5);\n"
"    #endif\n"
"\tN.xy *= u_NormalScale.xy;\n"
"\tN.z = sqrt(clamp((0.25 - N.x * N.x) - N.y * N.y, 0.0, 1.0));\n"
"\tN = tangentToWorld * N;\n"
"  #else\n"
"\tN = surfNormal;\n"
"  #endif\n"
"\n"
"\tN = normalize(N);\n"
"\n"
"  #if defined(USE_SHADOWMAP) \n"
"\tvec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"\tfloat shadowValue = texture2D(u_ShadowMap, shadowTex).r;\n"
"\n"
"\t// surfaces not facing the light are always shadowed\n"
"\tshadowValue *= clamp(dot(N, var_PrimaryLightDir.xyz), 0.0, 1.0);\n"
"\n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"\tlightColor *= shadowValue * (1.0 - u_PrimaryLightAmbient.r) + u_PrimaryLightAmbient.r;\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_PARALLAXMAP) && defined(USE_PARALLAXMAP_SHADOWS)\n"
"\toffsetDir = L * tangentToWorld;\n"
"\toffsetDir.xy *= u_NormalScale.a / offsetDir.z;\n"
"\tlightColor *= LightRay(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\n"
"\n"
"  #if !defined(USE_LIGHT_VECTOR)\n"
"\tambientColor = lightColor;\n"
"\tfloat surfNL = clamp(dot(surfNormal, L), 0.0, 1.0);\n"
"\n"
"\t// reserve 25% ambient to avoid black areas on normalmaps\n"
"\tlightColor *= 0.75;\n"
"\n"
"\t// Scale the incoming light to compensate for the baked-in light angle\n"
"\t// attenuation.\n"
"\tlightColor /= max(surfNL, 0.25);\n"
"\n"
"\t// Recover any unused light as ambient, in case attenuation is over 4x or\n"
"\t// light is below the surface\n"
"\tambientColor = max(ambientColor - lightColor * surfNL, vec3(0.0));\n"
"  #else\n"
"\tambientColor = var_ColorAmbient.rgb;\n"
"  #endif\n"
"\n"
"\tNL = clamp(dot(N, L), 0.0, 1.0);\n"
"\tNE = clamp(dot(N, E), 0.0, 1.0);\n"
"\tH = normalize(L + E);\n"
"\tEH = clamp(dot(E, H), 0.0, 1.0);\n"
"\tNH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"  #if defined(USE_SPECULARMAP)\n"
"\tvec4 specular = texture2D(u_SpecularMap, texCoords);\n"
"  #else\n"
"\tvec4 specular = vec4(1.0);\n"
"  #endif\n"
"\tspecular *= u_SpecularScale;\n"
"\n"
"  #if defined(USE_PBR)\n"
"\tdiffuse.rgb *= diffuse.rgb;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"\t// diffuse rgb is base color\n"
"\t// specular red is gloss\n"
"\t// specular green is metallicness\n"
"\tfloat gloss = specular.r;\n"
"\tfloat metal = specular.g;\n"
"\tspecular.rgb = metal * diffuse.rgb + vec3(0.04 - 0.04 * metal);\n"
"\tdiffuse.rgb *= 1.0 - metal;\n"
"  #else\n"
"\t// diffuse rgb is diffuse\n"
"\t// specular rgb is specular reflectance at normal incidence\n"
"\t// specular alpha is gloss\n"
"\tfloat gloss = specular.a;\n"
"\n"
"\t// adjust diffuse by specular reflectance, to maintain energy conservation\n"
"\tdiffuse.rgb *= vec3(1.0) - specular.rgb;\n"
"  #endif\n"
"\n"
"  #if defined(GLOSS_IS_GLOSS)\n"
"\tfloat roughness = exp2(-3.0 * gloss);\n"
"  #elif defined(GLOSS_IS_SMOOTHNESS)\n"
"\tfloat roughness = 1.0 - gloss;\n"
"  #elif defined(GLOSS_IS_ROUGHNESS)\n"
"\tfloat roughness = gloss;\n"
"  #elif defined(GLOSS_IS_SHININESS)\n"
"\tfloat roughness = pow(2.0 / (8190.0 * gloss + 2.0), 0.25);\n"
"  #endif\n"
"\n"
"\treflectance  = CalcDiffuse(diffuse.rgb, NH, EH, roughness);\n"
"\n"
"  #if defined(r_deluxeSpecular)\n"
"    #if defined(USE_LIGHT_VECTOR)\n"
"\treflectance += CalcSpecular(specular.rgb, NH, EH, roughness) * r_deluxeSpecular;\n"
"    #else\n"
"\treflectance += CalcSpecular(specular.rgb, NH, EH, pow(roughness, r_deluxeSpecular));\n"
"    #endif\n"
"  #endif\n"
"\n"
"\tgl_FragColor.rgb  = lightColor   * reflectance * (attenuation * NL);\n"
"\tgl_FragColor.rgb += ambientColor * diffuse.rgb;\n"
"\n"
"  #if defined(USE_CUBEMAP)\n"
"\treflectance = EnvironmentBRDF(roughness, NE, specular.rgb);\n"
"\n"
"\tvec3 R = reflect(E, N);\n"
"\n"
"\t// parallax corrected cubemap (cheaper trick)\n"
"\t// from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/\n"
"\tvec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"\n"
"  #if defined(USE_BOX_CUBEMAP_PARALLAX)\n"
"\tvec3 cubeLightColor = hitCube(R * u_CubeMapInfo.w, parallax, u_CubeMapInfo.www, ROUGHNESS_MIPS * roughness, u_CubeMap).rgb * u_EnableTextures.w;\n"
"  #else\n"
"\tvec3 cubeLightColor = textureCubeLod(u_CubeMap, R + parallax, ROUGHNESS_MIPS * roughness).rgb * u_EnableTextures.w;\n"
"  #endif\n"
"\n"
"\t// normalize cubemap based on last roughness mip (~diffuse)\n"
"\t// multiplying cubemap values by lighting below depends on either this or the cubemap being normalized at generation\n"
"\t//vec3 cubeLightDiffuse = max(textureCubeLod(u_CubeMap, N, ROUGHNESS_MIPS).rgb, 0.5 / 255.0);\n"
"\t//cubeLightColor /= dot(cubeLightDiffuse, vec3(0.2125, 0.7154, 0.0721));\n"
"\n"
"    #if defined(USE_PBR)\n"
"\tcubeLightColor *= cubeLightColor;\n"
"    #endif\n"
"\n"
"\t// multiply cubemap values by lighting\n"
"\t// not technically correct, but helps make reflections look less unnatural\n"
"\t//cubeLightColor *= lightColor * (attenuation * NL) + ambientColor;\n"
"\n"
"\tgl_FragColor.rgb += cubeLightColor * reflectance;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PRIMARY_LIGHT) || defined(SHADOWMAP_MODULATE)\n"
"\tvec3 L2, H2;\n"
"\tfloat NL2, EH2, NH2;\n"
"\n"
"\tL2 = var_PrimaryLightDir.xyz;\n"
"\n"
"\t// enable when point lights are supported as primary lights\n"
"\t//sqrLightDist = dot(L2, L2);\n"
"\t//L2 /= sqrt(sqrLightDist);\n"
"\n"
"\tNL2 = clamp(dot(N, L2), 0.0, 1.0);\n"
"\tH2 = normalize(L2 + E);\n"
"\tEH2 = clamp(dot(E, H2), 0.0, 1.0);\n"
"\tNH2 = clamp(dot(N, H2), 0.0, 1.0);\n"
"\n"
"\treflectance  = CalcSpecular(specular.rgb, NH2, EH2, roughness);\n"
"\n"
"\t// bit of a hack, with modulated shadowmaps, ignore diffuse\n"
"    #if !defined(SHADOWMAP_MODULATE)\n"
"\treflectance += CalcDiffuse(diffuse.rgb, NH2, EH2, roughness);\n"
"    #endif\n"
"\n"
"\tlightColor = u_PrimaryLightColor;\n"
"\n"
"    #if defined(USE_SHADOWMAP)\n"
"\tlightColor *= shadowValue;\n"
"    #endif\n"
"\n"
"\t// enable when point lights are supported as primary lights\n"
"\t//lightColor *= CalcLightAttenuation(float(u_PrimaryLightDir.w > 0.0), u_PrimaryLightDir.w / sqrLightDist);\n"
"\n"
"  #if defined(USE_PARALLAXMAP) && defined(USE_PARALLAXMAP_SHADOWS)\n"
"\toffsetDir = L2 * tangentToWorld;\n"
"\toffsetDir.xy *= u_NormalScale.a / offsetDir.z;\n"
"\tlightColor *= LightRay(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\n"
"\tgl_FragColor.rgb += lightColor * reflectance * NL2;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"\tgl_FragColor.rgb = sqrt(gl_FragColor.rgb);\n"
"  #endif\n"
"\n"
"#else\n"
"\n"
"\tgl_FragColor.rgb = diffuse.rgb * lightColor;\n"
"\n"
"#endif\n"
"\n"
"\tgl_FragColor.a = alpha;\n"
"}\n"
;
