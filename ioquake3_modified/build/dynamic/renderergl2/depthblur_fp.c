const char *fallbackShader_depthblur_fp =
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar, 1/width, 1/height\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"//float gauss[8] = float[8](0.17, 0.17, 0.16, 0.14, 0.12, 0.1, 0.08, 0.06);\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"//float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define BLUR_SIZE 4\n"
"\n"
"#if !defined(USE_DEPTH)\n"
"//#define USE_GAUSS\n"
"#endif\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar, vec2 scale)\n"
"{\n"
"\tfloat gauss[4];\n"
"\n"
"\tgauss[0] = 0.40;\n"
"\tgauss[1] = 0.24;\n"
"\tgauss[2] = 0.054;\n"
"\tgauss[3] = 0.0044;\n"
"\n"
"#if defined(USE_DEPTH)\n"
"\tfloat depthCenter = getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\tvec2 slope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\tscale /= clamp(zFarDivZNear * depthCenter / 32.0, 1.0, 2.0);\n"
"#endif\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"\tvec2 direction = vec2(scale.x * 2.0, 0.0);\n"
"\tvec2 nudge = vec2(0.0, scale.y * 0.5);\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"\tvec2 direction = vec2(0.0, scale.y * 2.0);\n"
"\tvec2 nudge = vec2(-scale.x * 0.5, 0.0);\n"
"#endif\n"
"\n"
"#if defined(USE_GAUSS)\n"
"\tvec4 result = texture2D(imageMap, tex) * gauss[0];\n"
"\tfloat total = gauss[0];\n"
"#else\n"
"\tvec4 result = texture2D(imageMap, tex);\n"
"\tfloat total = 1.0;\n"
"#endif\n"
"\n"
"\tfloat zLimit = 5.0 / zFar;\n"
"\tfor (int i = 0; i < 2; i++)\n"
"\t{\n"
"\t\tfor (int j = 1; j < BLUR_SIZE; j++)\n"
"\t\t{\n"
"\t\t\tvec2 offset = direction * (float(j) - 0.25) + nudge;\n"
"#if defined(USE_DEPTH)\n"
"\t\t\tfloat depthSample = getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\t\t\tfloat depthExpected = depthCenter + dot(slope, offset);\n"
"\t\t\tfloat useSample = float(abs(depthSample - depthExpected) < zLimit);\n"
"#else\n"
"\t\t\tfloat useSample = 1.0;\n"
"#endif\n"
"#if defined(USE_GAUSS)\n"
"\t\t\tresult += texture2D(imageMap, tex + offset) * (gauss[j] * useSample);\n"
"\t\t\ttotal += gauss[j] * useSample;\n"
"#else\n"
"\t\t\tresult += texture2D(imageMap, tex + offset) * useSample;\n"
"\t\t\ttotal += useSample;\n"
"#endif\n"
"\t\t\tnudge = -nudge;\n"
"\t\t}\n"
"\n"
"\t\tdirection = -direction;\n"
"\t\tnudge = -nudge;\n"
"\t}\n"
"\n"
"\treturn result / total;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tgl_FragColor = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y, u_ViewInfo.zw);\n"
"}\n"
;
